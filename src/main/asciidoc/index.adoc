= RoboVM Reference
:toc: left
:toclevels: 3
:icons: font
:source-highlighter: highlight.js
:appversion: 1.0.0-beta-04
:osxversion: 10.9
:xcodeversion: 6.x
:imagesdir: images

== Introduction

Mobile app developers targeting both Android and iOS face many challenges.
When comparing the native development environments of these two platforms,
i.e. the toolchains provided by Google and Apple respectively, one quickly
finds that they differ substantially. Android development, as defined by
Google, is based on the Eclipse IDE and the Java programming language. iOS
development, according to Apple, on the other hand is based on the Xcode IDE
and the Objective-C programming language. These differences rule out any code
reuse between the platforms. Also, not many developers are proficient in both
environments. In the end almost every multi-platform app is developed using
separate development teams and separate codebases for each platform.

The ultimate goal of the RoboVM project is to solve this problem without
compromising on neither developer nor app-user experience. With RoboVM
developing for both iOS and Android becomes less challenging; the same Java
developers can build both versions of the app and a large part of the codebase
can be shared.

=== Features

* Brings Java and other JVM languages, such as
  http://www.scala-lang.org/[Scala], http://clojure.org/[Clojure],
  http://groovy.codehaus.org/[Groovy] and http://kotlinlang.org/[Kotlin], to
  iOS devices.
* Translates Java bytecode into machine code
  http://en.wikipedia.org/wiki/Ahead-of-time_compilation[ahead-of-time] for
  fast execution directly on the CPU without any overhead. The main target is
  iOS and the ARM processor (32-bit and 64-bit) but there is also support for
  Mac OS X and Linux running on x86 CPUs (both 32-bit and 64-bit).
* Doesn't impose any restrictions on the Java platform features accessible to
  the developer, such as reflection or file I/O.
* Supports standard JAR files which lets the developer reuse the vast
  ecosystem of 3rd party Java libraries.
* Provides access to the
  https://developer.apple.com/technologies/ios/cocoa-touch.html[full native
  iOS APIs] through a Java to Objective-C bridge enabling the development of
  apps with truly native UIs and with full hardware access.
* Integrates with the most popular tools such as
  https://www.eclipse.org/[Eclipse], http://maven.apache.org/[Maven] and
  http://www.gradle.org/[Gradle].
* App Store ready. 

=== Limitations

There are a few limitations in RoboVM, mainly due to restrictions in the iOS
platform:

* Loading custom bytecode at runtime is not supported. All class files
  comprising the app have to be available at compile time on the developer
  machine.
* The http://en.wikipedia.org/wiki/Java_Native_Interface[Java Native
  Interface] technology as used on the desktop or on servers usually loads
  native code from dynamic libraries but Apple does not permit custom dynamic
  libraries to be shipped with an iOS app. RoboVM supports <<jni,a variant of
  JNI based on static libraries>>.

NOTE: RoboVM has *full* support for reflection.

////
TBW. Describes scope, use cases, how it works, features, limitations, users,
contributing, support options.
////

[id=getstarted]
== Getting Started

In this section you'll learn how to install RoboVM and make sure the toolchain
works correctly by creating a very simple demo app.

TIP: Wanna run RoboVM on Linux? You can build Linux console apps using RoboVM
at this time. Please see the
https://github.com/robovm/robovm/wiki/Get-started-on-Linux[RoboVM GitHub wiki]
for instructions.

=== Prerequisites

In order to use RoboVM the following is required:

* A Mac running Mac OS X {osxversion} or later
* http://www.oracle.com/technetwork/java/javase/downloads/index.html[Oracle's
  Java SE JDK 7]
* https://itunes.apple.com/us/app/xcode/id497799835?mt=12[Xcode {xcodeversion} from the
  Mac App Store]

IMPORTANT: Eclipse *MUST* be run using Oracle’s Java SE 7 JDK or later. Apple’s
Java 6 JVM will not work. Running Eclipse itself in Java 7 is not the same as
adding a Java 7 JRE to Eclipe's _Installed JREs_ dialog in _Preferences_. To
check which Java version Eclipse is running in go to _Eclipse -> About
Eclipse_, then click _Installation Details_ and open the _Configuration_ tab.
Find the `java.version` property and make sure it is 1.7 or higher.

IMPORTANT: The default max heap setting for Eclipse may be too low. In order
to increase it *you need to change the -Xmx setting used when launching
Eclipse*. To do this locate your Eclipse installation folder, right-click the
Eclipse file and select Show Package Contents. Open the `eclipse.ini` file
located in `Contents/MacOS` in a text editor and change the -Xmx value to 2G
or more. Restart Eclipse.

NOTE: The first time you install Xcode and every time you update to a new
version you have to open it once to agree to the Xcode terms.

=== RoboVM for Eclipse Plugin Installation

Once your system meets all the requirements you install the plugin by
selecting _Install New Software_ from the Eclipse _Help_ menu, enter the
following update site into the _Work with_ field and click _Next_:

----
http://download.robovm.org/eclipse/
----

[[img-eclipse-install-new-software]]
.Eclipse _Install New Software_ dialog
image::eclipse-install-new-software.png[]

NOTE: The RoboVM for Eclipse plugin is known to work with Eclipse 4.3 (Kepler)
and later. We recommend you use Eclipse version 4.4 (Luna) or later.

=== Command Line Tools Installation

To install the RoboVM command line tools just
http://download.robovm.org/robovm-{appversion}.tar.gz[download the latest
package], extract it and add the `robovm-{appversion}/bin/` folder to your
`$PATH` environment variable and set the `$ROBOVM_HOME` environment variable:

[source,bash,subs="attributes"]
----
$ curl -O 'http://download.robovm.org/robovm-{appversion}.tar.gz'
$ tar xvfz robovm-{appversion}.tar.gz
$ export ROBOVM_HOME=$(cd robovm-{appversion} ; pwd -P)
$ echo 'export ROBOVM_HOME="'"$ROBOVM_HOME"'"' >> ~/.profile
$ echo 'export PATH="$PATH:'$ROBOVM_HOME'/bin"' >> ~/.profile
----

If everything is working correctly you should see the command line usage help
text when you run
----
$ robovm -help
----

NOTE: If you change your `~/.profile` file you have to restart your shell or
open a new window or tab in Terminal for the changes to take effect.

[id=demo-app]
=== Your First iOS App

You should now be all set to run your first iOS app using RoboVM. In this section we will walk you through how to run a simple app <<iosdemo-eclipse>> and <<iosdemo-command-line>>.

[id="iosdemo-eclipse"]
==== In Eclipse

Create a new project using _File -> New -> Project..._ and select the _RoboVM
iOS Project_ wizard in the list.

[[img-ios-project-wizard]]
.The _RoboVM iOS Project wizard_
image::eclipse-ios-project-wizard.png[]

Enter `IOSDemo` as _Project name_, _App name_ and _Main class_. Enter
`org.robovm.IOSDemo` as _App id_. Click _Finish_.

[[img-create-project]]
.The _New RoboVM iOS Project_ dialog
image::eclipse-create-project.png[]

Now let's create that main class we specified in the new project dialog.
Create a new class and call it `IOSDemo` with no package name. Copy and paste
the code below into the newly created file replacing whatever Eclipse auto
generated for you.

[source,java]
----
include::IOSDemo.java[]
----

Finally, launch the app in the iOS simulator by right clicking the project you
created and select _Run As... -> iOS Simulator App (iPhone)_. This will run the
app on a simulated iPhone.

[[img-simulator]]
.The IOSDemo app running in the iOS simulator
image::simulator.png[width=300]

NOTE: To run the app on an actual device you would use the _Run As... -> iOS
Device App_ choice instead. Please note that this requires that the device has
been set up for development. Please refer to
https://developer.apple.com/library/ios/recipes/xcode_help-devices_organizer/articles/provision_device_for_development-generic.html[Apple's
documentation] for further information.

Check out the <<where-to-go-next>> section for pointers on where to go next.

[id="iosdemo-command-line"]
==== From the Command Line

We'll start off by creating a few directories:

[source,bash,subs="attributes"]
----
$ mkdir IOSDemo
$ cd IOSDemo/
$ mkdir src bin
----

Next create a new file called `IOSDemo.java` in the `src/` directory with the following contents:

[source,java]
----
include::IOSDemo.java[]
----

Compile `IOSDemo.java` using `javac`:

[source,bash,subs="attributes"]
----
$ javac -cp "$ROBOVM_HOME/lib/robovm-rt.jar:$ROBOVM_HOME/lib/robovm-objc.jar:$ROBOVM_HOME/lib/robovm-cocoatouch.jar" -d bin/ src/IOSDemo.java
----

Compile the Java bytecode into native code and launch the app using:

[source,bash,subs="attributes"]
----
$ robovm -verbose -arch x86 -os ios -cp "$ROBOVM_HOME/lib/robovm-objc.jar:$ROBOVM_HOME/lib/robovm-cocoatouch.jar:bin/" -run IOSDemo
----

[[img-simulator]]
.The IOSDemo app running in the iOS simulator
image::simulator.png[width=300]

[id="where-to-go-next"]
=== Where to go from here?

* Check out the <<the-robovm-for-eclipse-plugin>> section.
* If you'd rather use the command line you should check out the <<command-line-usage>> section.
* For more example projects have a look at the
  https://github.com/robovm/robovm-samples[RoboVM iOS samples project on GitHub].

== Under the hood

=== The bytecode compiler

At the heart of RoboVM is its
http://en.wikipedia.org/wiki/Ahead-of-time_compilation[ahead-of-time
compiler]. This is a tool that can be invoked either from the command line
(see <<command-line-usage>>), from build tools such as Maven (see
<<maven-integration>>) or Gradle or from an IDE (such as
<<the-robovm-for-eclipse-plugin,Eclipse>>). It takes Java bytecode and
translates it into machine code for a specific operating system and CPU type.
Usually this means iOS and the ARM processor type but RoboVM is also capable
of generating code for Mac OS X and Linux running on x86 CPUs.

The ahead-of-time approach is very different from how traditional JVMs, like
http://en.wikipedia.org/wiki/HotSpot[Oracle’s Hotspot], usually work. Such
JVMs typically read in Java bytecode at runtime and somehow execute the
virtual machine instructions contained in the bytecode. To speed up this
process the JVM employs a technique called
http://en.wikipedia.org/wiki/Just-in-time_compilation[just-in-time
compilation]. In simple terms this process translates the virtual machine
instructions of a method to native machine code for the current physical CPU
the first time the method is invoked by the program.

Due to technical restrictions that Apple has built into iOS just-in-time
compilation of any kind is impossible in an iOS app. The only alternatives are
to use an interpreter, which is too slow and power consuming, or use
ahead-of-time compilation like in RoboVM. The ahead-of-time compilation
process takes place at compile time on the developer machine so at runtime, on
an iOS device, the generated machine code runs at full speed, comparable to or
even faster than code compiled from Objective-C.

By consuming Java bytecode rather than Java source code the RoboVM
ahead-of-time compiler can, at least in theory, be used with any JVM language
that compiles down to bytecode. Scala, Clojure and Kotlin are JVM languages
already known to work. Another benefit with this approach is that RoboVM can
be used with 3rd party libraries in standard JAR files without any need for
the original source code enabling the use of proprietary and closed-source
libraries.

=== Incremental compilation

The first launch of a RoboVM app, even an app as simple as the `IOSDemo` app we
saw in <<demo-app>>, takes some time. When compiling an app the RoboVM
compiler starts with the app’s main class. It will then compile all classes
needed by the main class and then the classes needed by those classes and so
on until all classes needed by the app have been compiled. This process also
compiles the standard runtime classes such as `java.lang.Object` and
`java.lang.String`. This is a one-time thing only. RoboVM keeps a cache of
compiled classes and only recompiles a class when it or any of its direct
dependencies have changed.

TIP: By default RoboVM uses `$HOME/.robovm/cache/` as the cache folder. By
deleting this folder you can force RoboVM to recompile all classes from
scratch.

The benefit of incremental compilation and caching of the object files is that
it keeps down compile times. By only including the classes reachable from the
main class it also keeps down the size of the produced executable. In some
situations (e.g. when loading classes using reflection) the RoboVM compiler is
unable to determine that a class should be compiled. Fortunately the compiler
can be instructed to always <<config-reference,include a particular class or
even all classes matching a pattern>>.

=== Android-based runtime class library

Any JVM needs a runtime class library. This is the library which provides the
standard packages and classes needed by any Java program such as
`java.lang.Object` and `java.lang.String`. RoboVM takes its runtime class library
from the Android open-source project and all non-Android specific packages
have been ported over to RoboVM. This means that any Java or JVM language code
that only uses classes in the standard packages provided on Android should
work the same under RoboVM.

[id=config-reference]
== Configuration Reference

The recommended way to build RoboVM apps is to use a `robovm.xml` file to
configure the compiler. This section lists the supported elements and also the
corresponding command line options (if any).

The `robovm.xml` file is usually accompanied by a `robovm.properties` file.
The `robovm.xml` file will be searched for these properties and any matches
will be replaced with the actual value from the properties file. Properties
are referenced using the same `${...}` syntax as used by Maven, Gradle and
Ant. Here's and example:

.robovm.properties
[source]
app.executable=IOSDemo
app.name=IOSDemo

.robovm.xml
[source,xml]
<config>
  <executableName>${app.executable}</executableName>
  <mainClass>${app.mainclass}</mainClass>
  <os>ios</os>
  <arch>thumbv7</arch>
  <resources>
    <resource>
      <directory>resources</directory>
    </resource>
  </resources>
  <target>ios</target>
  <iosInfoPList>Info.plist.xml</iosInfoPList>
</config>

NOTE: All relative paths specified in a `robovm.xml` file will be resolved
relative to the file itself.

=== <installDir>

Specifies where to install the generated executable and other files. The
default is `<working-dir>/<executableName>`. For iOS apps the app will always
be created in a sub-folder in the specified `<installDir>` folder named like
the `CFBundleExecutable` value in the app´s `Info.plist.xml` file and with
`.app` appended.

.Example:
[source,xml]
<installDir>target/MyApp</installDir>

.Command line usage:
`-d <dir>`

=== <executableName>

Specifies the name of the executable to be generated.

.Example:
[source,xml]
<executableName>MyAppExe</executableName>

.Command line usage:
-o <name>

=== <useDynamicJni>

Specifies whether to use dynamic JNI. With this enabled native methods will be
dynamically linked at runtime. Native methods in classes in the boot classpath
will always use static JNI. On iOS only static JNI is supported and this
option is ignored. The default is `false`.

.Example:
[source,xml]
<useDynamicJni>true</useDynamicJni>

.Command line usage:
`-dynamic-jni`

=== <skipRuntimeLib>

Specifies whether the default `robovm-rt.jar` should be automatically added to the bootclasspath. The default is `true`

.Example:
[source,xml]
<skipRuntimeLib>false</skipRuntimeLib>

.Command line usage:
`-skiprt`

=== <mainJar>

This is the equivalent of the `-jar` command line option to the `java`
command. The jar file will be added to the classpath and RoboVM will use the
`Main-Class` set in the `META-INF/MANIFEST.MF` file in the jar file as
`<mainClass>` value. Either this or `<mainClass>` must be specified.

.Example:
[source,xml]
<mainJar>lib/my-app.jar</mainJar>

.Command line usage:
`-jar <file>`

=== <mainClass>

Specifies the fully-qualified name of the class containing the
`main(String[])` method that will be called when starting the app.  Either
this or `<mainJar>` must be specified.

.Example:
[source,xml]
<mainClass>com.example.MyApp</mainClass>

.Command line usage:
Specified after all RoboVM compiler options but before any program options.

=== <cacerts>

Specifies the cacerts file to be included in the app. RoboVM includes the same
CA cerificates as included in Android 4.4.3. Allowed values are `none` and
`full`. Default is `full` but no cacerts will be included unless the code
actually needs them.

.Example:
[source,xml]
<cacerts>none</cacerts>

.Command line usage:
`-cacerts <value>`

=== <os>

Specifies the name of the OS to build for. Allowed values are `auto`, `linux`,
`macosx` and `ios`. Default is `auto` which normally means to build for the
current host OS.

.Example:
[source,xml]
<os>ios</os>

.Command line usage:
`-os <name>`

=== <arch>

Specifies the name of the CPU architecture to compile for. Allowed values are
`auto`, `x86`, `x86_64`, `thumbv7`, `arm64`. Default is `auto` which  normally
means to build for the current host's CPU architecture.

.Example:
[source,xml]
<arch>thumbv7</arch>

.Command line usage:
`-arch <name>`

=== <forceLinkClasses>

Contains `<pattern>` elements listing class patterns matching classes that
must be linked in even if not referenced (directly or indirectly) from the
main class. If no main class is specified all classes will be linked in unless
this option has been given. Patterns are specified using an ANT style path
syntax with the following rules:

* `?` matches one character.
* `*` matches zero or more characters.
* `**` matches zero or more packages in a fully-qualified class name.

An alternative syntax using `#` is also supported. This is useful when
specifying patterns on the command line as it prevents the shall from
expanding `*` characters.

.Example:
[source,xml]
<forceLinkClasses>
  <pattern>com.android.okhttp.HttpHandler</pattern>
  <pattern>com.android.okhttp.HttpsHandler</pattern>
  <pattern>com.android.org.conscrypt.**</pattern>
</forceLinkClasses>

.Command line usage:
`-forcelinkclasses <list>`

NOTE: `-forcelinkclasses` can either be specified multiple times on the
command line, each specifying a single pattern or specified once with multiple
`:` separated patterns. E.g. `-forcelinkclasses
'com.example.Foo:com.example.bar.**'`.

=== <libs>

Specifies, in nested `<lib>` elements, static libraries (with extension `.a`),
object files (with extension `.o`) and system libraries that should be
included when linking the final executable.

If `force="true"` has been specified for a `<lib>` poining at a static library
the entire static library will be linked in regardless of whether the symbols
in it are referenced by the rest of the app's code or not. This uses the
`-force_load` command line linker option when building for Mac OS X and iOS
and `--whole-archive` when building for Linux. The default is `force="true"`.

.Example:
[source,xml]
<libs>
  <lib force="false">lib/libfoo.a</lib>
  <lib>lib/myobjectfile.o</lib>
  <lib>curl</lib>
</libs>

.Command line usage:
`-libs <list>`

NOTE: `-libs` can either be specified multiple times on the command line, each
specifying a single value or specified once with multiple `:` separated
values. E.g. `-libs 'lib/libfoo.a:curl'`.

CAUTION: There's no way to specify `force="false"` when using `-libs` from the
command line. Use a `robovm.xml` file instead.

=== <exportedSymbols>

Specifies, in nested `<symbol>` elements, symbols that should be exported when
linking the executable. This can be used when linking in functions which will
be called using <<bro,Bro>>. Wildcards can be used to match symbols:

* `*` matches zero or more characters,
* `?` matches one character. 
* `[abc]`, `[a-z]` matches one character from the specified set of characters.

.Example:
[source,xml]
<exportedSymbols>
  <symbol>CB*</symbol>
  <symbol>sin</symbol>
</exportedSymbols>

.Command line usage:
`-exportedsymbols <list>`

NOTE: `-exportedsymbols` can either be specified multiple times on the command line, each
specifying a single value or specified once with multiple `:` separated
values. E.g. `-exportedsymbols 'CB*:sin'`.

=== <frameworks>

Specifies, in nested `<framework>` elements, Mac OS X or iOS frameworks that
should be linked against when linking the final executable.

.Example:
[source,xml]
<frameworks>
  <framework>CoreImage</framework>
  <framework>UIKit</framework>
</frameworks>

.Command line usage:
`-frameworks <list>`

NOTE: `-frameworks` can either be specified multiple times on the command
line, each specifying a single value or specified once with multiple `:`
separated values. E.g. `-frameworks 'CoreImage:UIKit'`.

=== <weakFrameworks>

Specifies, in nested `<framework>` elements, Mac OS X or iOS frameworks that
should be weakly linked against when linking the final executable. Weakly
linking against a framework means that all symbols in the framework will be
marked as weakly linked. This allows apps to be built against one version of a
framework which defines a particular symbol and later run against a different
version of that framework which doesn't have that symbol defined. If that
symbol had been strongly linked the app would immediately crash at launch.

.Example:
[source,xml]
<weakFrameworks>
  <framework>CoreImage</framework>
  <framework>UIKit</framework>
</weakFrameworks>

.Command line usage:
`-weakframeworks <list>`

NOTE: `-weakframeworks` can either be specified multiple times on the command
line, each specifying a single value or specified once with multiple `:`
separated values. E.g. `-weakframeworks 'CoreImage:UIKit'`.

=== <frameworkPaths>

Specifies, in nested `<path>` elements, framework search paths used when
searching for custom frameworks.

.Example:
[source,xml]
<frameworkPaths>
  <path>lib/frameworks</path>
</frameworkPaths>

.Command line usage:
`-frameworkpaths <list>`

NOTE: `-frameworkpaths` can either be specified multiple times on the command
line, each specifying a single value or specified once with multiple `:`
separated values. E.g. `-frameworkpaths 'lib/frameworks:../frameworks'`.

=== <resources>

Specifies files and directories that should be copied to the installation
directory. A resource can be specified using a single path:

.Example:
[source,xml]
<resources>
  <resource>path/to/the/resource.txt</resource>
</resources>

NOTE: If the path specifies a directory, that directory including its contents
(except for the default excludes, see below) will be copied. If the path
specifies a file, that file will be copied directly to the installation directory.

A resource be also be specified with a base directory, a target path and include and exclude
filters (similar to Maven's `<resource>` element):

.Example:
[source,xml]
<resources>
  <resource>
   <targetPath>data</targetPath>
   <directory>resources</directory>
   <includes>
     <include>**/*</include>
   </includes>
   <excludes>
     <exclude>**/*.bak</exclude>
   </excludes>
   <flatten>false</flatten>
   <ignoreDefaultExcludes>false</ignoreDefaultExcludes>
   <skipPngCrush>false</skipPngCrush>
  </resource>
</resources>

==== <targetPath>

The target path relative to the installation directory (i.e. app bundle
directory for iOS apps) where paths matching this `<resource>` will be copied.
If not specified paths will be copied directly to the installation directory.

==== <directory>

The base directory containing the files and directories copied by the
`<resource>`.

==== <includes>

Specifies one or more Ant-style patterns (using `**`, `*` and `?` as
wildcards) matching files which will be included when copying this
`<resource>`.

==== <excludes>

Specifies one or more Ant-style patterns (using `**`, `*` and `?` as
wildcards) matching files which will be excluded when copying this
`<resource>`.

==== <flatten>

Set to `true` if the files matched by this `<resource>` should be copied
directly into the installation directory without preserving the directory
structure of the source directory. The default is `false`.

==== <ignoreDefaultExcludes>

Set to `true` if the <<defaultexcludes,default excludes>> should be ignored
and copied for this `<resource>`. The default is `false`, i.e. don't copy
files matching the default excludes.

==== <skipPngCrush>

Set this to `true` if `pngcrush` should not be called for PNG files matching
this `<resource>` when targeting iOS. The default is `false`,
i.e. `pngcrush` WILL be called for PNG files.

NOTE: Depending on the target (iOS, Mac OS X or Linux) resources may be
transformed and renamed while being copied (e.g. running `pngcrush` or
converting `xib` files to `nib` files).

[id="defaultexcludes"]
==== Default excludes

(The same as those used by Ant 1.9)

.Miscellaneous typical temporary files
[cols="5"]
|===
|+**/*~+
|+**/#*#+
|+**/.#*+
|+**/%*%+
|+**/._*+
|===

.CVS
[cols="3"]
|===
|+**/CVS+
|+**/CVS/**+
|+**/.cvsignore+
|===

.SCCS
[cols="2"]
|===
|+**/SCCS+
|+**/SCCS/**+
|===

.Visual SourceSafe
[cols="1"]
|===
|+**/vssver.scc+
|===

.Subversion
[cols="2"]
|===
|+**/.svn+
|+**/.svn/**+
|===

.Git
[cols="5"]
|===
|+**/.git+
|+**/.git/**+
|+**/.gitattributes+
|+**/.gitignore+
|+**/.gitmodules+
|===

.Mercurial
[cols="6"]
|===
|+**/.hg+
|+**/.hg/**+
|+**/.hgignore+
|+**/.hgsub+
|+**/.hgsubstate+

|+**/.hgtags+
|===

.Bazaar
[cols="3"]
|===
|+**/.bzr+
|+**/.bzr/**+
|+**/.bzrignore+
|===

.Mac
[cols="1"]
|===
|+**/.DS_Store+
|===

.Command line usage:
`-resources <list>`

NOTE: `-resources` can either be specified multiple times on the command line, each
specifying a single value or specified once with multiple `:` separated
values. E.g. `-resources '+resources/**:data/*+'`.

CAUTION: If a pattern is specified on the command line using `-resources` the
longest non-pattern path before the first wildcard will be used as base
directory and will not be recreated in the installation directory. E.g. with
the pattern `+resources/**+` all files and folders in the folder named
`resources` will be copied directly to the installation directory.

=== <bootclasspath>

Specifies, in nested `<classpathentry>` elements, directories, JAR archives,
and ZIP archives to search for class files to be compiled by the RoboVM
compiler. Classes in these entries will be loaded by the boot classloader at
runtime.  Used to locate the `+java.*+` and `+javax.*+` classes. Default is
`<robovm-home>/lib/robovm-rt.jar`.

.Example:
[source,xml]
<bootclasspath>
  <classpathentry>path/to/my/robovm-rt.jar</classpathentry>
</bootclasspath>

.Command line usage:
`-bootclasspath <list>`
`-bootcp <list>`
`-bcp <list>`

NOTE: `-bootclasspath` can either be specified multiple times on the command
line, each specifying a single value or specified once with multiple `:`
separated values.

CAUTION: When running RoboVM in an IDE like Eclipse or from a build tool such
as Maven or Gradle the `<bootclasspath>` and `<classpath>` elements in the
`robovm.xml` file will be ignored. Instead the classpaths of the IDE or build
tool with be used.

=== <classpath>

Specifies, in nested `<classpathentry>` elements, directories, JAR archives,
and ZIP archives to search for class files to be compiled by the RoboVM
compiler. Classes in these entries will be loaded by the system classloader at
runtime.

.Example:
[source,xml]
<classpath>
  <classpathentry>target/classes</classpathentry>
  <classpathentry>lib/commons-lang.jar</classpathentry>
</classpath>

.Command line usage:
`-classpath <list>`
`-cp <list>`

NOTE: `-classpath` can either be specified multiple times on the command line,
each specifying a single value or specified once with multiple `:` separated
values.

CAUTION: When running RoboVM in an IDE like Eclipse or from a build tool such
as Maven or Gradle the `<bootclasspath>` and `<classpath>` elements in the
`robovm.xml` file will be ignored. Instead the classpaths of the IDE or build
tool with be used.

////
=== <pluginArguments>
////

=== <targetType>

Specifies the target to build for. Either `auto`, `console` or `ios`. The default is
`auto` which means use `<os>` to decide.

.Example:
[source,xml]
<targetType>ios</targetType>

.Command line usage:
`-target <name>`

=== <iosSdkVersion>

(*iOS only*) Specifies the version number of the iOS SDK to build against. If not specified
the latest SDK that can be found will be used.

.Example:
[source,xml]
<iosSdkVersion>8.0</iosSdkVersion>

.Command line usage:
`-sdk <version>`

=== <iosInfoPList>

(*iOS only*) `Info.plist` file to be used by the app. If not specified a
simple `Info.plist` will be generated with a `CFBundleIdentifier` based on the
`<mainClass>` or `<executableName>`.

.Example:
[source,xml]
<iosInfoPList>plists/Info.plist</iosInfoPList>

.Command line usage:
`-plist <file>`

TIP: The specified `Info.plist` file will be searched for `${...}` patterns
just like `robovm.xml` files are. Such patterns will be replaced by the
corresponding property, usually read from a `robovm.properties` file.

=== <iosResourceRulesPList>

(*iOS only*) Property list (`.plist`) file containing resource rules passed to
`codesign` when signing the app.

.Example:
[source,xml]
<iosResourceRulesPList>plists/ResourceRules.plist</iosResourceRulesPList>

.Command line usage:
`-resourcerules <file>`

=== <iosEntitlementsPList>

(*iOS only*) Property list (`.plist`) file containing entitlements passed to
`codesign` when signing the app.

.Example:
[source,xml]
<iosEntitlementsPList>plists/Entitlements.plist</iosEntitlementsPList>

.Command line usage:
`-entitlements <file>`

[id="command-line-usage"]
== Command Line Usage

This section describes how to carry out some of the most common actions using
the `robovm` command line tool. For a complete usage reference for the options
supported by the `robovm` tool run

[source,bash]
----
$ robovm -help
----

=== Working with robovm.xml files

Almost everything can be done directly from the command line using the
options of the `robovm` command but it is still recommended to use an
<<config-reference,XML configuration file>> called `robovm.xml` to configure
the compiler.

The `-dumpconfig` option can be used to create a `robovm.xml` file. This
creates a `robovm.xml` file for the demo app in <<demo-app>>:

[source,bash]
----
$ robovm -arch thumbv7 -os ios -cp "$ROBOVM_HOME/lib/robovm-objc.jar:$ROBOVM_HOME/lib/robovm-cocoatouch.jar:bin/" -dumpconfig robovm.xml IOSDemo
----

Once we have the `robovm.xml` file we only have to specify it on the command
line to launch the app. This would launch the app on a connected device since
the `robovm.xml` file specifies the `thumbv7` architecture:

[source,bash]
----
$ robovm -config robovm.xml -run
----

TIP: You can load multiple configurations by specifying `-config` multiple
times. The latter ones take precedence.

We can override the configuration read from a `robovm.xml` file by specifying the options we want to override after the `robovm.xml` file has been read in. To launch on the iOS simulator we need to build for the `x86` architecture so we use the `-arch` option *after* the configuration file has been specified:

[source,bash]
----
$ robovm -config robovm.xml -arch x86 -run
----

We can even "edit" the `robovm.xml` file by combining `-config` and `-dumpconfig`. This adds a new classpath entry:

[source,bash]
----
$ robovm -config robovm.xml -cp foo.jar -dumpconfig robovm-new.xml
$ mv robovm-new.xml robovm.xml
----

=== Expanding properties in robovm.xml files

XML configuration files (and also `Info.plist` files) will be searched for `${...}` patterns. Such patterns will be replaced with properties loaded using the `-properties` command line option which reads in `.properties` file. Individual properties can also be specified directly on the command line using the `-Pname=value` option.

=== Launching apps

To launch an app using the command line tool you simply specify the `-run`
command line option. RoboVM will use the configured target OS (`-os`) and
architecture (`-arch`) to determine how to launch the app.

To launch in the iOS simulator use `-os ios` `-arch x86`:

[source,bash]
----
$ robovm -cp ... -os ios -arch x86 -run com.example.MainClass
----

To launch on an iOS device in 32-bit mode use `-os ios` `-arch thumbv7`:

[source,bash]
----
$ robovm -cp ... -os ios -arch thumbv7 -run com.example.MainClass
----

To launch on an iOS device in 64-bit mode use `-os ios` `-arch arm64`:

[source,bash]
----
$ robovm -cp ... -os ios -arch arm64 -run com.example.MainClass
----

RoboVM also supports building Mac OS X console apps. This is what you get if
you don't specify any `-os` or `-arch` (or use `-os macosx` `-arch x86`):

[source,bash]
----
$ robovm -cp ... -run com.example.MainClass
----

=== Packaging for App Store/Ad-Hoc distribution

The `-createipa` option is used to create an
http://en.wikipedia.org/wiki/.ipa_(file_extension)[IPA file] which can be
submitted to the App Store or distributed to beta tester or throughout an
enterprise.

NOTE: Before you can do this you will have to have your signing certificates
and provisioning profiles in order. Apple has some
https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012582-CH1-SW1[great
resources] that describe how to enroll in the iOS developers program and
create the certificates and provisioning profiles required for App Store
distribution.


This will create an IPA file signed with the code signing certificate matching
_iPhone Distribution_ and using the provisioning profile named __My
Distribution Profile__. The IPA will be stored in `~/Desktop/IPA/`:

[source,bash]
----
$ robovm -config robovm.xml -signidentity 'iPhone Distribution' -provisioningprofile 'My Distribution Profile' -d ~/Desktop/IPA/ -createipa
----

TIP: The `-signingidentiy` option matches against the start of the certificate
name. Alternatively you can use a certificate fingerprint. If the
`-signingidentiy` value is enclosed in `/` a regexp search will be done
against the certificate name instead. Run the command `security find-identity
-v -p codesigning` or use the _KeyChain Access_ OS X app to view your
installed certificates.

CAUTION: The IPA creation also creates a `.dSYM` folder in the folder you
specify with `-d`. The `.dSYM` contains the debug symbols of your app. It is
required if you want to symbolicate a crash report generated by your app. To
symbolicate you need the exact `.dSYM` so *make sure you back this up*.

The IPA is now ready to be distributed. To submit the IPA file to the App
Store you would use the _Application Loader_ application that comes with
Xcode. The _Application Loader_ application can easily be located using
_Spotlight_.

[id="the-robovm-for-eclipse-plugin"]
== Using the RoboVM for Eclipse Plugin

////
TIP: The iOS project you just created looks pretty much like an ordinary Java
project. But instead of the usual _JRE System Library_ containing Oracle's
runtime class library this project instead uses the _RoboVM Runtime Library_.
The _RoboVM Runtime Library_ contains all those packages you are used to
seeing in a Java project like `java.lang`, `java.util`, etc. The classes in
the _RoboVM Runtime Library_ have been ported over from the Android standard
class library.

TIP: The iOS project also references the _RoboVM CocoaTouch Library_ which contains
bindings for the
https://developer.apple.com/technologies/ios/cocoa-touch.html[iOS CocoaTouch
APIs]. With these bindings you can do pretty much anything you could have done
if you had developed your app in Objective-C (or Swift) using Apple's tools:
build native GUIs, access the hardware such as bluetooth and the GPS, access
contacts, handle in-app payments, display ads, etc.

Notes about what Eclipse created for us. robovm.properties, robovm.xml,
Info.plist.xml and resources/.

TBW. How to create new project. How to run on console, iOS simulator, iOS
device. How to package IPA for App Store or Ad-Hoc distribution. Run JUnit
test.
////

[id="maven-integration"]
== Maven Integration

////
TBW. Describes Maven configuration and supported goals. How to run on console,
iOS simulator, iOS device. How to package IPA for App Store or Ad-Hoc
distribution. Run JUnit tests.
////

[id=jni]
== Using the Java Native Interface (JNI)

[id=bro]
== The Bro Java to Native Bridge

Bro is a RoboVM specific API that enables Java code to call directly into
native code without using JNI. It has been inspired by
https://github.com/twall/jna[JNA], http://code.google.com/p/bridj/[BridJ] and
http://en.wikipedia.org/wiki/Platform_Invocation_Services[.NET's P/Invoke].
Bro is the Swedish word for bridge and is pronounced broo.

We'll introduce bro with a simple example:

[source,java]
----
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;

@Library("c") // <1>
public class Abs {
    static {
        Bro.bind(); // <3>
    }
    @Bridge private static native int abs(int i); // <2>
    public static void main(String[] args) {
        System.out.println(abs(-100));
    }
}
----
<1> The `@Library` annotation tells Bro to look for symbols in the `libc`
system library. Bro will prepend `lib` and append `.so` to the specified
library name when searching for a matching library

<2> The `@Bridge` annotated `Abs.abs()` method will bind to the native
http://pubs.opengroup.org/onlinepubs/009695399/functions/abs.html[`abs()`]
function in `libc`.

<3> The `Bro.bind()` call initiates the lookup of native functions and binds
them to the corresponding `@Bridge` annotated methods. This process relies
on
http://pubs.opengroup.org/onlinepubs/009695399/functions/dlopen.html[`dlopen()`]
and
http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html[`dlsym()`]
to find matching symbols.

=== Primitive type marshaling

==== Primitive Java types

Native integer types (e.g. `char`, `int32_t`, `float`) are mapped to Java
integer types of the same size:

|===
|Java |Bits |Example C type {asterisk}

|byte
|8
|char, uint8_t

|short
|16
|short

|char
|16
|uint16_t

|int
|32
|int, int32_t

|long
|64
|long long, int64_t

|float
|32
|float

|double
|64
|double
|===

{asterisk} Depends on compiler and platform

NOTE: Unsigned types (e.g. `uint32_t`) are mapped to the signed Java type of
the same bit size.

==== Platform dependent primitive types

Some native types have varying bit sizes depending on the target platform.
E.g. the C `long` type is usually a 32-bit integer on 32-bit platforms but a
64-bit integer on 64-bit platforms. To support such types Bro provides three
different annotations:

===== @MachineSizedFloat

`@MachineSizedFloat` is used to bind floating point types which are 32-bit on
32-bit platforms and 64-bit on 64-bit platforms. The `CGFloat` type in Apple's
Cocoa and CocoaTouch APIs is an example of such a type. `CGFloat` is bound
using `@MachineSizedFloat double` in RoboVM's CocoaTouch bindings. On the Java
side the value is kept in a `float` or `double` and Bro will take care of the
native<-->Java conversion.

.Example usage:
The C function which returns x^y^ of a `CGFloat` value
[source,c]
----
CGFloat pow(CGFloat x, CGFloat y);
----
would be bound like this using Bro:
[source,java]
----
@Bridge
public native @MachineSizedFloat double abs(
    @MachineSizedFloat double x,
    @MachineSizedFloat double y);
----

NOTE: The method parameter or return type annotated with `@MachineSizedFloat`
must either have the Java type `float` or `double`.

CAUTION: When using `@MachineSizedFloat float` on 64-bit platforms Bro will
cast the native value from a 64-bit `double` to a 32-bit `float` value when
converting a native value to a Java value. This operation may result in loss
of precision. The same situation occurs when using `@MachineSizedFloat double`
on 32-bit platforms and passing a Java value to native code.

===== @MachineSizedSInt

`@MachineSizedSInt` is used to bind signed integer types which are 32-bit on
32-bit platforms and 64-bit on 64-bit platforms. The `NSInteger` type in
Apple's Cocoa and CocoaTouch APIs is an example of such a type. `NSInteger` is
bound using `@MachineSizedSInt long` in RoboVM's CocoaTouch bindings. On the
Java side the value is always kept in a `long` and Bro will take care of the
native<-->Java conversion.

.Example usage:
The C function which returns the asbolute of an `NSInteger` value
[source,c]
----
NSInteger abs(NSInteger v);
----
would be bound like this using Bro:
[source,java]
----
@Bridge
public native @MachineSizedSInt long abs(
    @MachineSizedSInt long v);
----

NOTE: The method parameter or return type annotated with `@MachineSizedSInt`
must have the Java type `long`.

===== @MachineSizedUInt

`@MachineSizedUInt` is used to bind signed integer types which are 32-bit on
32-bit platforms and 64-bit on 64-bit platforms. The `NSUInteger` type in
Apple's Cocoa and CocoaTouch APIs is an example of such a type. `NSUInteger`
is bound using `@MachineSizedUInt long` in RoboVM's CocoaTouch bindings. On
the Java side the value is always kept in a `long` and Bro will take care of
the native<-->Java conversion.

.Example usage:
The C function which returns the max of two `NSUInteger` values
[source,c]
----
NSUInteger max(NSUInteger a, NSUInteger b);
----
would be bound like this using Bro:
[source,java]
----
@Bridge
public native @MachineSizedUInt long max(
    @MachineSizedUInt long a, 
    @MachineSizedUInt long b);
----

NOTE: The method parameter or return type annotated with `@MachineSizedUInt`
must have the Java type `long`.

==== Pointers

Pointers are passed as Java `long` values annotated with the Bro `@Pointer`
annotation. The Bro compiler will handle the 64-bit <--> 32-bit conversions on
32-bit platforms.

.Example usage:
The C `malloc()` function
[source,c]
----
void *malloc(size_t size);
----
could be bound like this using Bro:
[source,java]
----
@Bridge
public native @Pointer long malloc(
    @MachineSizedUInt long size);
----

===== Primitive type pointer classes

Bro provides special pointer classes for each of the Java primitive types
which makes it easier to work with pointers to primitive types. Using these
classes facilitates converting between Java arrays of primitives and native
memory, converting pointers to direct `java.nio.Buffer` instances and more.
These classes are located in the http://apidocs.robovm.com/latest/org/robovm/rt/bro/ptr/package-summary.html[`org.robovm.rt.bro.ptr`] package.

.Example of using the `BytePtr` class:
The C `getenv()` function
[source,c]
----
char *getenv(const char *name);
----
can be bound like this using Bro in RoboVM:
[source,java]
----
@Bridge
public native BytePtr getenv(BytePtr name);
----
And used like this to print out the value of `$HOME`:
[source,java]
----
public static void main(String[] args) {
    BytePtr value = getenv(BytePtr.toBytePtrAsciiZ("HOME"));
    System.out.println(value.toStringAsciiZ());
}
----

=== Structs

C `struct` types are mapped to Java by extending the bro http://apidocs.robovm.com/latest/org/robovm/rt/bro/Struct.html[`Struct`] class. Each
member of the C `struct` is bound using a getter method and a setter method
that must be `native` and annotated with the bro `@StructMember` annotation.
The `@StructMember` annotation specifies the index of the member in the
`struct`. The getter method must take 0 parameters and return some value while
the setter method must take 1 parameter of the same type as the getter
returns. The return type for the setter must either be `void` or the `Struct`
class it belongs to.

TIP: The names of the getter and setter methods don't have to follow the Java
Beans style convention for Java Beans properties.

TIP: If the setter method is declared as returning an instance of the `Struct`
class it belongs to the Bro compiler will make it return `this` making it
possible to chain setter method calls.

.Example struct:
The C `struct timeval`
[source,c]
----
struct timeval {
    time_t       tv_sec;   /* seconds since Jan. 1, 1970 */
    suseconds_t  tv_usec;  /* and microseconds */
};
----
can be bound like this using Bro in RoboVM:
[source,java]
----
public class Timeval extends Struct<Timeval> {
    @StructMember(0) public native int tv_sec();
    @StructMember(0) public native Timeval tv_sec(int i);
    @StructMember(1) public native int tv_usec();
    @StructMember(1) public native Timeval tv_usec(int i);
}
----
And used like this to call http://pubs.opengroup.org/onlinepubs/009695399/functions/gettimeofday.html[`gettimeofday()`]:
[source,java]
----
@Bridge static native int gettimeofday(Timeval tp, VoidPtr tzp);
public static void main(String[] args) {
    Timeval t = new Timeval();
    gettimeofday(t, null);
    System.out.format("Seconds since epoch: %d\n", t.tv_sec());
}
----

==== sizeof(struct)

The size in bytes of a `Struct` can easily be queried by calling the static
`sizeOf()` method on the `Struct` sub-class:

[source,java]
----
public class CGRect extends Struct<CGRect> { ... }
System.out.format("sizeof(CGRect) = %d\n", CGRect.sizeOf());
----

==== @ByRef and @ByVal

The `@ByRef` and `@ByVal` annotations can be used to control how a `Struct`
object is returned from a method or passed as a parameter to a method.
`@ByRef` means pass as pointer and is the default. `@ByVal` means pass by
value. The default can be changed to `@ByVal` for a particular `Struct` class
by annotating the class with `@ByVal`:

[source,java]
----
@ByVal
public class Person extends Struct<Person> { ... }
----

==== Nested structs

`Struct` classes can contain other `Struct` objects as members, either by
value or by reference (i.e. by pointer). The default is `@ByRef` with the same
possibilities to override the default as for methods.

Below is an example of how the CocoaTouch `struct CGRect` type is mapped to
Java in the RoboVM Cocoa Touch bindings. A `CGRect` has two members: the
`origin` is a `CGPoint` `struct` and the `size` is a `CGSize` struct.

.C:
[source,c]
----
struct CGRect {
    CGPoint origin;
    CGSize  size;
};
----
.Java:
[source,java]
----
public class CGRect extends Struct<CGRect> {
    public CGRect() {}
    public CGRect(float x, float y, float width, float height) {
        origin().x(x).y(y);
        size().width(width).height(height);
    }
    public CGRect(CGPoint origin, CGSize size) {
        origin(origin);
        size(size);
    }
    @StructMember(0) public native @ByVal CGPoint origin();
    @StructMember(0) public native CGRect origin(@ByVal CGPoint origin);
    @StructMember(1) public native @ByVal CGSize size();
    @StructMember(1) public native CGRect size(@ByVal CGSize size);
}
----

==== Unions

A C `union` is bound just like a C `struct` but has overlapping
`@StructMember` indexes:

.C:
[source,c]
----
union TestUnion {
    int i;
    short s1;
    short s2;
};
----
.Java:
[source,java]
----
public class TestUnion extends Struct<TestUnion> {
    @StructMember(0) public native int i();
    @StructMember(0) public native TestUnion i(int i);
    @StructMember(0) public native short s1();
    @StructMember(0) public native TestUnion s1(short s1);
    @StructMember(0) public native short s2();
    @StructMember(0) public native TestUnion s2(short s2);
}
----

==== Native array members

Bro provides the `@Array` annotation which is used to bind array struct
members. The `@Array` annotation specifies the dimensions of the member's
type. Space large enough to hold a native array of the specified type and
dimensions will be reserved inside the struct.

Single-dimensional array:

.C:
[source,c]
----
struct Vector {
    int values[3];
};
----
.Java:
[source,java]
----
public class Vector extends Struct<Vector> {
    @StructMember(0) 
    public native @Array(3) int[] values();
    @StructMember(0) 
    public native Vector values(@Array(3) int[] values);
}
----

Multi-dimensional array:

.C:
[source,c]
----
struct Matrix {
    int values[1, 2, 3];
};
----
.Java:
[source,java]
----
public class Matrix extends Struct<Matrix> {
    @StructMember(0) 
    public native @Array({1, 2, 3}) int[][][] values();
    @StructMember(0) 
    public native Matrix values(@Array({1, 2, 3}) int[][][] values);
}
----

NOTE: The native data will be copied to and from the `int[]` and `int[][][]`
arrays in these examples. Changes in the Java arrays will not be directly
reflected in the native data. The setter has to be called to update the native
data.

An alternative to using Java arrays is to use a sub-class of `java.nio.Buffer`
instead:

Single-dimensional array:

.C:
[source,c]
----
struct Vector {
    int values[3];
};
----
.Java:
[source,java]
----
public class Vector extends Struct<Vector> {
    @StructMember(0) 
    public native @Array(3) IntBuffer values();
    @StructMember(0) 
    public native Vector values(@Array(3) IntBuffer values);
}
----

Multi-dimensional array:

.C:
[source,c]
----
struct Matrix {
    int values[1, 2, 3];
};
----
.Java:
[source,java]
----
public class Matrix extends Struct<Matrix> {
    @StructMember(0) 
    public native @Array({1, 2, 3}) IntBuffer values();
    @StructMember(0) 
    public native Matrix values(@Array({1, 2, 3}) IntBuffer values);
}
----

NOTE: The buffer's `capacity()` will be restricted to the dimension of the
array. For multi-dimensional arrays this is the product of the dimensions,
1*2*3=6 for the `Matrix` example.

A third option is to use one of the pointer classes in the
http://apidocs.robovm.com/latest/org/robovm/rt/bro/ptr/package-summary.html[`org.robovm.rt.bro.ptr`]
package:

Single-dimensional array:

.C:
[source,c]
----
struct Vector {
    int values[3];
};
----
.Java:
[source,java]
----
public class Vector extends Struct<Vector> {
    @StructMember(0) 
    public native @Array(3) IntPtr values();
    @StructMember(0) 
    public native Vector values(@Array(3) IntPtr values);
}
----

Multi-dimensional array:

.C:
[source,c]
----
struct Matrix {
    int values[1, 2, 3];
};
----
.Java:
[source,java]
----
public class Matrix extends Struct<Matrix> {
    @StructMember(0) 
    public native @Array({1, 2, 3}) IntPtr values();
    @StructMember(0) 
    public native Matrix values(@Array({1, 2, 3}) IntPtr values);
}
----

It's also possible to have arrays of structs in a `Struct`:

.C:
[source,c]
----
struct Color {
    char r; char g; char b;
};
struct Gradient {
    Color stops[3];
};
----
.Java:
[source,java]
----
public class Color extends Struct<Color> { ... }
public class Gradient extends Struct<Gradient> {
    @StructMember(0) public native @Array(3) Color[] stops();
    @StructMember(0) public native Gradient stops(@Array(3) Color[] stops);
}
----

==== Unbounded native array members

For unbounded native array members one should use one of the pointer classes
in the
http://apidocs.robovm.com/latest/org/robovm/rt/bro/ptr/package-summary.html[`org.robovm.rt.bro.ptr`]
package combined with the `@ByVal` annotation:

.C:
[source,c]
----
struct PascalString {
    int length;
    char chars[];
};
----
.Java:
[source,java]
----
public class PascalString extends Struct<PascalString> {
    @StructMember(0) public native int length();
    @StructMember(0) public native PascalString length(int length);
    @StructMember(0) public native @ByVal BytePtr chars();
}
----

NOTE: There's no setter for the `chars` member as that would have required the
length to be known at compile time. Setting the individual bytes of `chars`
has to be done through the `BytePtr` returned by the getter.

==== Struct memory handling

When creating an instance of a `Struct` class Bro actually allocates two
memory regions: one for the Java object and one for the actual struct data.
The default is to allocate the struct data on the Java heap. There are two way
to make sure that the underlying struct data is allocated on the GCed heap:

[source,java]
----
CGRect r = new CGRect();
CGRect r = Struct.allocate(CGRect.class);
----

This means that the data will be garbage collected when the garbage collector
determines that the struct data isn't referenced from any other memory
allocated on the garbage collected heap.

Allocating struct data on the GCed heap won't work for native code that holds
on to a pointer to the struct data beyond a Java call into a native function
since the native heap is not searched by the garbage collector. If the native
side assumes ownership of the data and later frees it by a call to `free()`
the Java side has to use `malloc()` to allocate it on the native heap:

[source,java]
----
CGRect r = Struct.malloc(CGRect.class);
----

CAUTION: If the native side holds on to a memory region allocated on the GCed
heap care must be taken on the Java side to make sure that the memory isn't
collected until the native side is done with it. As long as the Java `Struct`
instance is referenced on the Java side the struct data can't be collected.

TIP: The memory region allocated to hold a struct's data will always be zeroed
out regardless of whether using the Java heap or the native heap.

=== Native arrays

This allocates an array of 10 `CGRect` instances:

[source,java]
----
public class CGRect extends Struct<CGRect> { ... }
CGRect l = Struct.allocate(CGRect.class, 10);
----

This allocates a contiguous memory region big enough to hold 10 `CGRect`
instances. The `Struct` class defines a number of methods that can be used to
iterate over these, e.g.
http://apidocs.robovm.com/latest/org/robovm/rt/bro/Struct.html#next()[`next()`]
and
http://apidocs.robovm.com/latest/org/robovm/rt/bro/Struct.html#previous()[`previous()`].
`Struct` also implements the `Iterable` interface:

[source,java]
----
for (CGRect r : l) {
    ...
    if (<some condition>) {
        break;
    }
}
----

CAUTION: The `Iterator` used when `for`-looping like this is unbounded so a
`break` is required to finish the loop.

The
http://apidocs.robovm.com/latest/org/robovm/rt/bro/ptr/BytePtr.html[`BytePtr`]
class and the other pointer classes in
http://apidocs.robovm.com/latest/org/robovm/rt/bro/ptr/package-summary.html[`org.robovm.rt.bro.ptr`]
are in fact `Struct` classes so to allocate a native array of 100 `int` values
one could do:

[source,java]
----
IntPtr myInts = Struct.allocate(IntPtr.class, 100);
----

=== Enums

Simple C `enum` constants are mapped using Java `Enum` types which implement
the bro
http://apidocs.robovm.com/latest/org/robovm/rt/bro/ValuedEnum.html[`ValuedEnum`]
interface. Here's an example:

.C:
[source,c]
----
enum {
   NSTextAlignmentLeft,
   NSTextAlignmentCenter,
   NSTextAlignmentRight,
   NSTextAlignmentJustified,
   NSTextAlignmentNatural
};
----

.Java:
[source,java]
----
public enum NSTextAlignment implements ValuedEnum {
    Left(0), Center(1), Right(2),
    Justified(3), Natural(4);

    private final long n;

    private NSTextAlignment(long n) { this.n = n; }
    public long value() { return n; }
    public static NSTextAlignment valueOf(long n) {
        for (NSTextAlignment v : values()) {
            if (v.n == n) {
                return v;
            }
        }
        throw new IllegalArgumentException(
            "No constant with value " + n + " found in " 
                + NSTextAlignment.class.getName());
    }
}
----

By default Bro marshals a `ValuedEnum` as a signed 32-bit value. The default
can be changed by specifying an explicit `@Marshaler` on the enum type. Here's
how to marshal `NSTextAlignment` values as platform dependent (32-bit on
32-bit platforms, 64-bit on 64-bit platforms) signed integer values:

.Overriding the default marshaler for a `ValuedEnum`:
[source,java]
----
@Marshaler(ValuedEnum.AsMachineSizedSIntMarshaler.class)
public enum NSTextAlignment implements ValuedEnum {
    ...
}
----

There are `ValuedEnum` marshalers for marshaling signed and unsigned 8-, 16-,
32- and 64-bit integer values. They are all available as http://apidocs.robovm.com/latest/org/robovm/rt/bro/ValuedEnum.html[inner classes in the
`ValuedEnum` interface].

TIP: The `@Marshaler` annotation can also be placed on a particular method return
type or parameter type to only change the marshaler for that specific value.

=== Bits

Bro provides a class called
http://apidocs.robovm.com/1.0.0-SNAPSHOT/org/robovm/rt/bro/Bits.html[`Bits`]
that can be used to bind bitmask constants:

.C:
[source,c]
----
enum {
    UIPopoverArrowDirectionUp    = 1UL << 0,
    UIPopoverArrowDirectionDown  = 1UL << 1,
    UIPopoverArrowDirectionLeft  = 1UL << 2,
    UIPopoverArrowDirectionRight = 1UL << 3,
    ...
};
----

.Java:
[source,java]
----
public final class UIPopoverArrowDirection 
        extends Bits<UIPopoverArrowDirection> {

    public static final UIPopoverArrowDirection None = 
            new UIPopoverArrowDirection(0L);
    public static final UIPopoverArrowDirection Up = 
            new UIPopoverArrowDirection(1L);
    public static final UIPopoverArrowDirection Down = 
            new UIPopoverArrowDirection(2L);
    public static final UIPopoverArrowDirection Left = 
            new UIPopoverArrowDirection(4L);
    public static final UIPopoverArrowDirection Right = 
            new UIPopoverArrowDirection(8L);
    ...    

    private static final UIPopoverArrowDirection[] values = 
        _values(UIPopoverArrowDirection.class);

    public UIPopoverArrowDirection(long value) { super(value); }
    private UIPopoverArrowDirection(long value, long mask) {
        super(value, mask);
    }
    protected UIPopoverArrowDirection wrap(long value, long mask) {
        return new UIPopoverArrowDirection(value, mask);
    }
    protected UIPopoverArrowDirection[] _values() {
        return values;
    }
    public static UIPopoverArrowDirection[] values() {
        return values.clone();
    }
}
----

`Bits` values can be ORed using the `Bits.with(...)` methods in a manner very
similar to how `java.util.EnumSet.of(...)` works:

.C:
[source,c]
----
int upDown = UIPopoverArrowDirectionUp | UIPopoverArrowDirectionDown;
----

.Java:
[source,java]
----
UIPopoverArrowDirection upDown = UIPopoverArrowDirection.with(
    UIPopoverArrowDirection.Up, UIPopoverArrowDirection.Down);
----

TIP: `Bits` types is the preferred way to bind bitmasks since it provides some
degree of type-safety and an easier to understand API. It does however impose
a performance penalty compared to using `public static final` constants.

By default Bro marshals a `Bits` instance as an unsigned 32-bit value. The
default can be changed by specifying an explicit `@Marshaler` on the class.
Here's how to marshal `UIPopoverArrowDirection` values as platform dependent
(32-bit on 32-bit platforms, 64-bit on 64-bit platforms) unsigned integer
values:

.Overriding the default marshaler for a `Bits`:
[source,java]
----
@Marshaler(Bits.AsMachineSizedIntMarshaler.class)
public final class UIPopoverArrowDirection 
        extends Bits<UIPopoverArrowDirection> {
    ...
}
----

There are `Bits` marshalers for marshaling unsigned 8-, 16-, 32- and 64-bit
integer values. They are all available as
http://apidocs.robovm.com/latest/org/robovm/rt/bro/Bits.html[inner
classes in the `Bits` interface].

TIP: The `@Marshaler` annotation can also be placed on a particular method return
type or parameter type to only change the marshaler for that specific value.

=== Native functions

=== Global values

=== Callback methods

=== Type marshalers

Type marshalers are used by Bro to convert from native types into Java types
and vice versa. 

==== Marshaler lookup

==== Value marshalers

==== Array marshalers

==== Pointer marshalers

Pointer marshalers marshal pointers to native objects to/from some Java object
that wraps that pointer. The general contract for a pointer marshaler class
looks like this:

[source,java]
----
public class MyTypeMarshaler {
    @MarshalsPointer
    public static MyType toObject(Class<?> cls, long handle, long flags) {
        ...
    }
    @MarshalsPointer
    public static long toNative(MyType o, long flags) {
        ...
    }
}
----

This marshaler marshals `MyType` instances to/from native pointers (`handle`).
Bro uses the signatures of the `@MarshalsPointer` methods to determine whether
it is a method which marshals Java->native or native->Java. The Java type it
can handle is determined by the signature (`MyType` in this case).

The `cls` parameter specifies the actual `Class` used at the marshaling site.
The passed in `Class` is assignment compatible with the `MyType` class or
interface.

The `flags` parameter gives some information on the call site. The possible
values are defined by
http://apidocs.robovm.com/latest/org/robovm/rt/bro/MarshalerFlags.html[`MarshalerFlags`]
class.

TIP: Marshaler method names are unimportant, the signatures are what matters.

==== Builtin marshalers

=== Binding linked in libraries

=== Binding Objective-C

=== Objective-C/Java Memory Management

=== The bro-gen tool

== Cross-Platform Development

////
TBW. Describes best practices when developing iOS and Android versions of an
app trying to reuse as much code as possible.
////

////
== JavaFX on iOS
////

////
== Tips \'n' tricks
////

////
List signing identities, provisioning profiles.
Wipe class cache.
Fix black screen in iOS app due to GC.
////

== Hacking on RoboVM
